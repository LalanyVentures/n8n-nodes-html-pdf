import type {
	IExecuteFunctions,
	INodeExecutionData,
	INodeType,
	INodeTypeDescription,
} from 'n8n-workflow';
import { NodeConnectionTypes, NodeOperationError } from 'n8n-workflow';

// ðŸ‘‡ add type imports from puppeteer
import type { Browser, PDFOptions } from 'puppeteer';
import puppeteer from 'puppeteer';

export class HtmlPdf implements INodeType {
	description: INodeTypeDescription = {
		displayName: 'HTML to PDF',
		name: 'htmlPdf',
		icon: { light: 'file:example.svg', dark: 'file:example.dark.svg' },
		group: ['transform'],
		version: 1,
		description: 'Convert HTML content to a PDF file (using Puppeteer)',
		defaults: {
			name: 'HTML to PDF',
		},
		inputs: [NodeConnectionTypes.Main],
		outputs: [NodeConnectionTypes.Main],
		usableAsTool: true,
		properties: [
			{
				displayName: 'HTML Source',
				name: 'htmlSource',
				type: 'options',
				options: [
					{
						name: 'Field: "html" on Input Item',
						value: 'input',
						description: 'Use item.json.html from previous node',
					},
					{
						name: 'Parameter',
						value: 'parameter',
						description: 'Provide HTML directly in this node',
					},
				],
				default: 'parameter',
				description: 'Where to read HTML content from',
			},
			{
				displayName: 'HTML',
				name: 'html',
				type: 'string',
				typeOptions: {
					rows: 8,
				},
				default: '<h1>Hello PDF</h1><p>Generated by n8n custom node.</p>',
				displayOptions: {
					show: {
						htmlSource: ['parameter'],
					},
				},
				description: 'HTML content to convert to PDF (ignored if using input item)',
			},
			{
				displayName: 'File Name',
				name: 'fileName',
				type: 'string',
				default: 'output.pdf',
				description: 'Name of the generated PDF file',
			},
			{
				displayName: 'Paper Format',
				name: 'format',
				type: 'options',
				options: [
					{ name: 'A4', value: 'A4' },
					{ name: 'Letter', value: 'Letter' },
					{ name: 'Legal', value: 'Legal' },
				],
				default: 'A4',
				description: 'Page size for the PDF',
			},
			{
				displayName: 'Print Background',
				name: 'printBackground',
				type: 'boolean',
				default: true,
				description: 'Whether to print background graphics',
			},
		],
	};

	async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
		const items = this.getInputData();
		const returnItems: INodeExecutionData[] = [];

		let browser: Browser | undefined;

		try {
			browser = await puppeteer.launch({
				executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser',
				args: ['--no-sandbox', '--disable-setuid-sandbox'],
			});

			for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
				try {
					const htmlSource = this.getNodeParameter('htmlSource', itemIndex) as string;

					let html = '';
					if (htmlSource === 'parameter') {
						html = this.getNodeParameter('html', itemIndex, '') as string;
					} else {
						const item = items[itemIndex];
						if (!item.json || typeof item.json.html !== 'string') {
							throw new NodeOperationError(
								this.getNode(),
								'Expected item.json.html to be a string when HTML Source is "Field: \\"html\\" on Input Item".',
								{ itemIndex },
							);
						}
						html = item.json.html as string;
					}

					const fileName = this.getNodeParameter('fileName', itemIndex, 'output.pdf') as string;
					const format = this.getNodeParameter('format', itemIndex) as PDFOptions['format'];
					const printBackground = this.getNodeParameter('printBackground', itemIndex) as boolean;

					const page = await browser.newPage();
					await page.setContent(html, { waitUntil: 'networkidle0' });

					const pdfBuffer = await page.pdf({
						format,
						printBackground,
					});

					await page.close();

					const binaryData = await this.helpers.prepareBinaryData(
						Buffer.from(pdfBuffer),
						fileName,
						'application/pdf',
					);

					// Preserve original JSON, add binary
					const newItem: INodeExecutionData = {
						json: items[itemIndex].json,
						binary: {
							data: binaryData,
						},
					};

					returnItems.push(newItem);
				} catch (error) {
					if (this.continueOnFail()) {
						returnItems.push({
							json: {
								error: (error as Error).message,
							},
							pairedItem: itemIndex,
						});
						continue;
					}

					if ((error as any).context) {
						(error as any).context.itemIndex = itemIndex;
						throw error;
					}

					throw new NodeOperationError(this.getNode(), error as Error, {
						itemIndex,
					});
				}
			}
		} finally {
			if (browser) {
				await browser.close();
			}
		}

		return [returnItems];
	}
}
