"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.HtmlPdf = void 0;
const n8n_workflow_1 = require("n8n-workflow");
const puppeteer_1 = __importDefault(require("puppeteer"));
class HtmlPdf {
    constructor() {
        this.description = {
            displayName: 'HTML to PDF',
            name: 'htmlPdf',
            icon: { light: 'file:example.svg', dark: 'file:example.dark.svg' },
            group: ['transform'],
            version: 1,
            description: 'Convert HTML content to a PDF file (using Puppeteer)',
            defaults: {
                name: 'HTML to PDF',
            },
            inputs: [n8n_workflow_1.NodeConnectionTypes.Main],
            outputs: [n8n_workflow_1.NodeConnectionTypes.Main],
            usableAsTool: true,
            properties: [
                {
                    displayName: 'HTML Source',
                    name: 'htmlSource',
                    type: 'options',
                    options: [
                        {
                            name: 'Field: "html" on Input Item',
                            value: 'input',
                            description: 'Use item.json.html from previous node',
                        },
                        {
                            name: 'Parameter',
                            value: 'parameter',
                            description: 'Provide HTML directly in this node',
                        },
                    ],
                    default: 'parameter',
                    description: 'Where to read HTML content from',
                },
                {
                    displayName: 'HTML',
                    name: 'html',
                    type: 'string',
                    typeOptions: {
                        rows: 8,
                    },
                    default: '<h1>Hello PDF</h1><p>Generated by n8n custom node.</p>',
                    displayOptions: {
                        show: {
                            htmlSource: ['parameter'],
                        },
                    },
                    description: 'HTML content to convert to PDF (ignored if using input item)',
                },
                {
                    displayName: 'File Name',
                    name: 'fileName',
                    type: 'string',
                    default: 'output.pdf',
                    description: 'Name of the generated PDF file',
                },
                {
                    displayName: 'Paper Format',
                    name: 'format',
                    type: 'options',
                    options: [
                        { name: 'A4', value: 'A4' },
                        { name: 'Letter', value: 'Letter' },
                        { name: 'Legal', value: 'Legal' },
                    ],
                    default: 'A4',
                    description: 'Page size for the PDF',
                },
                {
                    displayName: 'Print Background',
                    name: 'printBackground',
                    type: 'boolean',
                    default: true,
                    description: 'Whether to print background graphics',
                },
            ],
        };
    }
    async execute() {
        const items = this.getInputData();
        const returnItems = [];
        let browser;
        try {
            browser = await puppeteer_1.default.launch({
                executablePath: process.env.PUPPETEER_EXECUTABLE_PATH || '/usr/bin/chromium-browser',
                args: ['--no-sandbox', '--disable-setuid-sandbox'],
            });
            for (let itemIndex = 0; itemIndex < items.length; itemIndex++) {
                try {
                    const htmlSource = this.getNodeParameter('htmlSource', itemIndex);
                    let html = '';
                    if (htmlSource === 'parameter') {
                        html = this.getNodeParameter('html', itemIndex, '');
                    }
                    else {
                        const item = items[itemIndex];
                        if (!item.json || typeof item.json.html !== 'string') {
                            throw new n8n_workflow_1.NodeOperationError(this.getNode(), 'Expected item.json.html to be a string when HTML Source is "Field: \\"html\\" on Input Item".', { itemIndex });
                        }
                        html = item.json.html;
                    }
                    const fileName = this.getNodeParameter('fileName', itemIndex, 'output.pdf');
                    const format = this.getNodeParameter('format', itemIndex);
                    const printBackground = this.getNodeParameter('printBackground', itemIndex);
                    const page = await browser.newPage();
                    await page.setContent(html, { waitUntil: 'networkidle0' });
                    const pdfBuffer = await page.pdf({
                        format,
                        printBackground,
                    });
                    await page.close();
                    const binaryData = await this.helpers.prepareBinaryData(Buffer.from(pdfBuffer), fileName, 'application/pdf');
                    const newItem = {
                        json: items[itemIndex].json,
                        binary: {
                            data: binaryData,
                        },
                    };
                    returnItems.push(newItem);
                }
                catch (error) {
                    if (this.continueOnFail()) {
                        returnItems.push({
                            json: {
                                error: error.message,
                            },
                            pairedItem: itemIndex,
                        });
                        continue;
                    }
                    if (error.context) {
                        error.context.itemIndex = itemIndex;
                        throw error;
                    }
                    throw new n8n_workflow_1.NodeOperationError(this.getNode(), error, {
                        itemIndex,
                    });
                }
            }
        }
        finally {
            if (browser) {
                await browser.close();
            }
        }
        return [returnItems];
    }
}
exports.HtmlPdf = HtmlPdf;
//# sourceMappingURL=HtmlPdf.node.js.map